// node.setAttributeNS(null, "draggable", "true");
// node.addEventListener("dragstart", (event) => {
    //     event.dataTransfer.dropEffect = "move";
    //     event.dataTransfer.setData("textplain", event.target.id);
    // });



// setAttributes(newLine, {"x1": x1 + radius*Math.cos(theta), "y1": y1 + radius*Math.sin(theta), "x2": center[0] - radius*Math.cos((Math.PI/2) - theta), "y2": center[1] - radius*Math.sin((Math.PI/2) - theta), "style": "stroke:black;stroke-width:4", "marker-end": "url(#arrowhead)"});



/* <marker id='head' orient="auto" markerWidth='2' markerHeight='4' refX='0.1' refY='2'>
    <!-- triangle pointing right (+x) -->
     <path d='M0,0 V4 L2,2 Z' fill="red"/>
</marker>
<path marker-end='url(#head)' fill='none' stroke='black' d='M0,0 C45,45 45,-45 90,0' /> */

/* <svg viewBox="0 0 500 500">
<circle style="fill:url(#toning);stroke:#010101;" cx="250" cy="250" r="245"> </circle>
<text x="50%" y="50%" text-anchor="middle" stroke="#51c5cf" stroke-width="2px" dy=".3em">Look, I’m centered!Look, I’m centered!</text>
</svg> */

/* 
<line x1="0" y1="0" x2="200" y2="200" style="stroke:rgb(255,0,0);stroke-width:2" />
<circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
<defs>
    <marker id="triangle" viewBox="0 0 10 10"
    refX="1" refY="5" markerUnits="strokeWidth"
    markerWidth="10" markerHeight="10" orient="auto">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="#f00"/>
    </marker>
</defs>
<polyline fill="none" stroke="black" points="20,100 40,60 70,80 100,20" marker-end="url(#triangle)"/>
*/







STYLES OLD:
body{
    margin: 0px;
    padding: 0px;
    font-family: Arial, Helvetica, sans-serif;
    height: 100vh;
}
header{
    width: 100%;
    background: rgb(40, 57, 76);
    text-align: center;
    height: 50px;
}
header ul{
    display: flex;
    justify-content: space-evenly;
    width: 100%;
    padding: 0;
    margin: 0 auto;
    /* list-style: none;
    background-color: rgb(40, 57, 76); 
    flex-direction: row;
    align-items: baseline;
    text-align: center;
    height: 50px;
    position: absolute;
    vertical-align: middle; */
}
header ul li{
    list-style: none;
    position: relative;
    padding: 0px;
    transition: 0.5s;
    box-sizing: border-box;
    /* margin: 0;
    margin: auto;
    width: 20%; */
}
header ul li a{
    text-decoration: none;
    padding: 0;
    margin: 0;
    color: rgb(71, 182, 160);
}
/*header ul li:hover .dropdown{
    display: block;
}*/
.dropdown{
    position: absolute;
    top: 45px; /* CHANGE */
    left: 0px;
    margin: 0;
    padding: 0;
    background: orange;
    display: block;
}
.dropdown:last-child{
    border-radius: 0 0 4px 4px;
}
header ul li:hover{
    background: green;
}
.dropdown li:hover{
    background-color: antiquewhite;
    color: orange;
}

#logo{
    color: white;
}
.content{
    background-color: orange;
    margin: 0;
    padding: 0;
    top: -500px;
    height: 250px;
} 

/*TODO: Adjust height inside dropdown */










/* header ul{
    list-style: none;
    padding: 0;
    margin: 0;
    display: inline-block;
    background-color: lightseagreen;
    /* border-radius: 5px; 
    width: 100%;
}
header ul li{ /* Greedy, Dynamic, Sorting, Misc options
    float: left;
    width: 20%;
    height: 50px;
    line-height: 50px;
    position: relative;
}
header ul li:hover{
    background-color: pink;
    /* border-radius: 5px; 
}
ul.dropdown{
    position: absolute;
    top: 100%;
    left: 0%;
    width: 100%;
    padding: 0;
}
ul.dropdown li{
    background-color: #666;
    color: black;
    height: 50px;
    flex-wrap: wrap;
}
ul.dropdown li:hover{
    background-color: #606060;
}

ul.dropdown li{
    display: none;
}
li:hover > ul.dropdown li{
    display: block;
} */

/* header{
    background-color: rgb(173, 216, 255);
    text-align: center;
    width: 100%;
}
header ul{
    display: inline-block;
}
header ul, .shown{
    margin: 0px;
    padding: 0px;
    height: 50px;
    width: 20%;
}
.shown{
    display: block;
    flex-direction: column;
    background-color: rgb(173, 216, 255);
    border-radius: 3px;
}
header ul li{
    float: left;
    height: 65px;
}
.shown li{
    height: 100px;
}
header ul li, .shown li{
    list-style-type: none;
    display: inline-block;
    margin: auto;
}
header ul li a, .shown li a{
    text-decoration: none;    
    color: white;
    transition: color 0.2s ease-out;
}
header ul li a:hover, .dropdown li a:hover{ 
    color: grey;
}

.triangle{
    opacity: 35%;
} */





// Gradient attempt:
<linearGradient id="lightGradient" gradientUnits="userSpaceOnUse">
    <stop offset = "0" stop-color="blue">
        <animate attributeName = "offset" values = "0;1" dur = "5s" repeatCount = "indefinite" fill="freeze"></animate>
    </stop>
    <stop offset = "0" stop-color="black"></stop>
</linearGradient>

I tried to do a gradient animation. I scrapped it because:
    a) With polygons, arrowhead is stretched which looks weird.
    b) With line, synchronizing line and arrow animations is difficult. The animation is visually "done" way sooner than the onend event triggers.
    c) Time. Faster to change color than animate it in.



console.log(parseFloat(outgoing.getAttribute("x1")) + dx, parseFloat(outgoing.getAttribute("y1")) - dy, parseFloat(outgoing.getAttribute("x2")) + dx, parseFloat(outgoing.getAttribute("y2")) - dy);
console.log(x1 - dx, y1 + dy, center[0] - dx, center[1] + dy);






function dijkstra() {
    // for (let node in lines){
    //     for(let line of lines[node]){
    //         // setAttributes(line, {"stroke": "blue", "marker-end": "url(#arrowheadBlue)"})
    //     }
    // }
}



//TODO: Move item, recalculate edges.
    group.addEventListener("mousedown", (event) => {
        draggedItem = event.target;
        console.log("MOUSEDOWN");
    });
    group.addEventListener("mousemove", (event) => {
        if(draggedItem && !priorNode){
            let newX = event.offsetX;
            let newY = event.offsetY;
            console.log(`Dragged ${group.childNodes[0].id}`)
            setAttributes(group, {"x": newX, "y": newY});
            setAttributes(group.childNodes[0], {"cx": newX, "cy": newY});
            setAttributes(group.childNodes[1], {"x": newX-0.5, "y": newY+4});
            // // Move outgoing edges:
            // for(let outgoing of lines[node.id]){
            //     if(adjacencyList[outgoing.end].includes(node.id)){ // Incoming edge as well, so endpoints won't be center.

            //     }else{
            //         setAttributes(outgoing.lineObject, {"x1": newX, "y1": newY});
            //     }
            // }
        }
    });
    group.addEventListener("mouseup", (event) => {
        draggedItem = null;
        console.log("MOUSEUP");
    })






    
    // if(c != undefined){
    //     svg.removeChild(c);
    // }
    // c = document.createElementNS(svgns, "rect");
    // setAttributes(c, {"x": label.getAttribute("x") - labelWidth/2, "y": label.getAttribute("y")-labelHeight/2, "width": labelWidth, "height": labelHeight, "style":"fill:none;stroke:pink;stroke-width:1"});
    // svg.appendChild(c);






    // 2 options: Have transparent parent rectangle around each text, onclick set fill to not transparent. With this, we could potentially keep the text highlighted and stay in edit mode while dragging since we would update the rectangle position to begin with.
    //            Add external rectangle (not a parent) around the text on click. This makes it a little harder to stay in edit mode while dragging, but I like this better: no wasted rectangles that are always transparent except upon edit (even then, only one isn't transparent at a time). Furthermore, I don't want to be able to edit and drag at the same time: once you click out the text, we exit edit mode. GO WITH THIS ONE. 
                









OLD MAIN.JS:
// OLD CODE. DO NOT USE.


let svgns = "http://www.w3.org/2000/svg";
let svg = document.querySelector("svg");

borderColor = "transparent";
fillColor = "orange";
textColor = "white";

function setAttributes(element, attributes){
    for (let key in attributes){
        element.setAttribute(key, attributes[key]);
    }
} 

let h = 6;
let w = 4;
colors = ["Black", "Blue"];
let defs = document.createElementNS(svgns, "defs");
for (color of colors){
    for (distance of ["Near", "Far"]){
        let arrowheadMarker = document.createElementNS(svgns, "marker");
        setAttributes(arrowheadMarker, {"id": `arrowhead${color}_${distance}`, "markerWidth": w, "markerHeight": h, "refX": distance == "Near" ? 0 : w, "refY": w/2, "orient": "auto", "fill": color});
        let arrowhead = document.createElementNS(svgns, "polygon");
        arrowhead.setAttribute("points", `0 0, ${h} ${w/2}, 0 ${w}`);
        arrowheadMarker.appendChild(arrowhead);   
        defs.appendChild(arrowheadMarker);  
    }
}
svg.appendChild(defs);

let sourceNode = newLine = draggedItem = null;
let numNodes = 0;
// Upon moving the mouse to after clicking a node to create a new edge, the gradient will change as direction and length changes. currentGradient is the most updated gradient we added, so we can remove it when we NEXT move the mouse so there is only ever 1 extra line gradient (the current one) at a time, vs. a gradient fro each individual mousemove (potentially thousands).


let currentGradient = document.createElementNS(svgns, "linearGradient");

let adjacencyList = {}; // startID: [endIds]
let lines = {}; // startID: [{lineObject, gradient}]
let func = () => {};

let algorithms = document.querySelectorAll(".dropdown li");
for(let algorithm of algorithms){
    algorithm.addEventListener("click", () => {
        func = window[algorithm.classList[0]]
    });
}






// TODO: update gradient function to be a solid black line, that ends at (x2, y2) - heightOfArrow. No gradient necessary, just stop black line.
function getGradient(x1, y1, x2, y2, id, x){
    let gradient = document.createElementNS(svgns, "linearGradient");
    let distance = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
    setAttributes(gradient, {"id": id});
    let numerator = distance-3*w;
    let color1 = "black", color2 = "transparent";
    if(x2 < x1){
        numerator = 3*w;
        color1 = "transparent", color2 = "black";
    }
    let stop1 = document.createElementNS(svgns, "stop");
    let stop2 = document.createElementNS(svgns, "stop");
    if(distance == 0){
        distance = 0.001;
    }
    if(x){
    console.log("cutoff: ", numerator*100/distance);
    }
    setAttributes(stop1, {"offset":`${numerator*100/distance}%`, "stop-color": color1});
    setAttributes(stop2, {"offset":`${numerator*100/distance}%`, "stop-color": color2});
    gradient.append(stop1, stop2);
    return gradient;
}


svg.addEventListener("mousemove", (event) => {
    if(newLine != null){
        let x2 = event.offsetX;
        let y2 = event.offsetY;
        let priorX = sourceNode.cx.baseVal.value;
        let priorY = sourceNode.cy.baseVal.value;
        setAttributes(newLine, {"x2": x2, "y2": y2});
        [dx, dy] = getShifts(priorX, priorY, x2, y2);
        if(svg.contains(currentGradient)){
            svg.removeChild(currentGradient);
        }
        currentGradient = getGradient(priorX, priorY, x2, y2, `${x2}${y2}`, false);
        svg.appendChild(currentGradient);
        newLine.setAttribute("stroke", `url(#${x2}${y2})`);
    }else if(draggedItem != null){
        event.preventDefault();
        setAttributes(draggedItem, {"cx": event.offsetX, "cy": event.offsetY});
        setAttributes(draggedItem.nextElementSibling, {"x": event.offsetX-0.5, "y": event.offsetY+4});
        setAttributes(draggedItem.parentElement, {"x": event.offsetX, "y": event.offsetY});
        updateAllLines(draggedItem);
    }
})

// TODO: Update with unpacking arguments
function updateLine(line, x1, y1, x2, y2, g){
    if(x1 != undefined){
        line.setAttribute("x1", x1);
    }
    if(y1 != undefined){
        line.setAttribute("y1", y1);
    }
    if(x2 != undefined){
        line.setAttribute("x2", x2);
    }
    if(y2 != undefined){
        line.setAttribute("y2", y2);
    }
    if(g != undefined){
        line.setAttribute("stroke", `url(#${g.id})`);
    }
}

// For node's incoming edges, set x2 to newX and y2 to newY. For outgoing, set x1 to newX and y1 to newY. Adjust for double link.
//TODO: Find out why gradient is clear.
function updateAllLines(node){
    if(node == null || node == undefined || adjacencyList[node.id] == undefined){
        return;
    }
    // Handle outgoing + double link.
    for(let i = 0; i < adjacencyList[node.id].length; i++){
        let endNodeId = adjacencyList[node.id][i];
        let sourceNode = svg.getElementById(endNodeId);// source of incoming edge.
        let g2 = getGradient(node.cx.baseVal.value, node.cy.baseVal.value, sourceNode.cx.baseVal.value, sourceNode.cy.baseVal.value, lines[node.id][i].gradient.id, true); // Outgoing
        if(adjacencyList[endNodeId].includes(node.id)){
            // Double connection.
            let g1 = getGradient(sourceNode.cx.baseVal.value, sourceNode.cy.baseVal.value, node.cx.baseVal.value, node.cy.baseVal.value, lines[endNodeId][adjacencyList[endNodeId].indexOf(node.id)].gradient.id, false); // Incoming
            updateDoubleConnection(lines[endNodeId][adjacencyList[endNodeId].indexOf(node.id)].lineObject, lines[node.id][i].lineObject, sourceNode.cx.baseVal.value, sourceNode.cy.baseVal.value, node.cx.baseVal.value, node.cy.baseVal.value, g1, g2);
        }else{
            // Single connection. Just outgoing edge.
            updateLine(lines[node.id][i].lineObject, node.cx.baseVal.value, node.cy.baseVal.value, undefined, undefined, g2);
        }
    }

    for(let i = 0; i < Object.keys(adjacencyList).length; i++){
        if(adjacencyList[i].includes(node.id) && !adjacencyList[node.id].includes(i)){
            // Incoming edge, not doubly linked:
            let sourceNode = svg.getElementById(i);// source of incoming edge.
            let g = getGradient(node.cx.baseVal.value, node.cy.baseVal.value, sourceNode.cx.baseVal.value, sourceNode.cy.baseVal.value, lines[i][adjacencyList[i].indexOf(node.id)].gradient.id, false);
            updateLine(lines[i][adjacencyList[i].indexOf(node.id)].lineObject, undefined, undefined, node.cx.baseVal.value, node.cy.baseVal.value, g);
        }
    }
}

function getShifts(xOriginal, yOrignal, xClicked, yClicked){
    let theta = Math.atan((yClicked-yOrignal)/(xOriginal-xClicked));
    let dx = Math.sin(theta);
    let dy = Math.cos(theta);
    if(xOriginal < yOrignal){ 
        dx = -dx
        dy = -dy;
    }
    return [dx, dy]
}

// (x1,y1) are coordinates of start of line of incoming edge. (x2, y2) is the tip.
function updateDoubleConnection(incoming, outgoing, x1, y1, x2, y2, g1, g2){
    let [dx, dy] = getShifts(x1, y1, x2, y2);
    updateLine(incoming, parseFloat(x1) - (w/2)*dx, parseFloat(y1) - (w/2)*dy, parseFloat(x2) - (w/2)*dx, parseFloat(y2) - (w/2)*dy, g1);
    updateLine(outgoing, parseFloat(x2) + (w/2)*dx, parseFloat(y2) + (w/2)*dy, parseFloat(x1) + (w/2)*dx, parseFloat(y1) + (w/2)*dy, g2);
}

let addButton = document.getElementsByClassName("add")[0];
addButton.addEventListener("click", () => {
    let radius = window.innerWidth/30;
    let group = document.createElementNS(svgns, "g");
    let node = document.createElementNS(svgns, "circle");
    setAttributes(node, {"r" : radius, "cx" :  Math.random() * svg.width.baseVal.value, "cy": Math.random() * svg.height.baseVal.value, "fill": fillColor, "style": `stroke:${borderColor};stroke-width:4`, "id": numNodes});

    let newText = document.createElementNS(svgns, "text");
    setAttributes(newText, {"text-anchor": "middle", "x": parseFloat(node.cx.baseVal.value)-0.5, "y": parseFloat(node.cy.baseVal.value)+4, "font-weight": "bold", "font-size": "16", "fill": textColor, "class": "disableSelect"});
    newText.textContent = numNodes;
    adjacencyList[numNodes] = []
    lines[numNodes++] = []
    group.append(node, newText);
    svg.appendChild(group);
    
    group.addEventListener("click", (event) => {
        if(sourceNode == null){ // First node.
            sourceNode = node;
            newLine = document.createElementNS(svgns, "line");
            setAttributes(newLine, {"x1": node.cx.baseVal.value, "y1": node.cy.baseVal.value, "x2": node.cx.baseVal.value, "y2": node.cy.baseVal.value, "style": "stroke-width:4",  "marker-end": "url(#arrowheadBlackNear)", "pointer-events": "none", "stroke": "black"});
            svg.appendChild(newLine);
        }else if (sourceNode != node && !adjacencyList[sourceNode.id].includes(node.id)) { // Second node to establish connection.
            adjacencyList[sourceNode.id].push(node.id);

            let priorX = node.cx.baseVal.value;
            let priorY = node.cy.baseVal.value;
            // Deep copy of current gradient:
            let gradient = getGradient(priorX, priorY, node.cx.baseVal.value, node.cy.baseVal.value, `${sourceNode.id}_${node.id}`, true);
            svg.appendChild(gradient);
            svg.removeChild(currentGradient);
            // If nodes already have an edge connecting them the other way, adjust positions:
            if(adjacencyList[node.id].includes(sourceNode.id)){ // Outgoing edge already exists. Incoming being created.
                let index = adjacencyList[node.id].indexOf(`${sourceNode.id}`);
                let outgoing = lines[node.id][index].lineObject;
                updateDoubleConnection(newLine, outgoing, priorX, priorY, node.cx.baseVal.value, node.cy.baseVal.value, gradient, undefined);
            }else{
                updateLine(newLine, sourceNode.cx.baseVal.value, sourceNode.cy.baseVal.value, node.cx.baseVal.value, node.cy.baseVal.value, gradient);
            }
            
            lines[sourceNode.id].push({lineObject: newLine, gradient: gradient});
            newLine = sourceNode = null;
        }
    });
    svg.addEventListener("mousedown", (event) => {
        draggedItem = event.target;
    })
    svg.addEventListener("mouseup", (event) => {
        draggedItem = null;
    })
});

END OLD MAIN.JS




OLD PLAY BUTTON CSS

/* .circle {
    stroke: var(--play-hover-color);
    stroke-dasharray: 200;
    stroke-dashoffset: 200;
    transition: all 0.5s ease-in-out;
    opacity: 0.3;
}
.playBut {
    display: inline-block;
    width:50px;
    height:50px;
    position: absolute;
    bottom: 70px;
    right: 10px;
    transition: all 0.5s ease;
}
.playBut .triangle {
    transition: all 0.7s ease-in-out;
    stroke-dasharray: 240;
    stroke-dashoffset: 480;
    stroke: #000;
    transform: translateY(0);
}
.playBut:hover .triangle {
    stroke-dashoffset: 0;
    opacity: 1;
    stroke: var(--play-hover-color);
}
.playBut:hover .circle {
    stroke-dashoffset: 0;
    opacity: 1;
} */

END OLD PLAY BUTTON CSS

OLD PLAY BUTTON HTML

<!-- <div class="playBut" onclick="func()">
    <svg>
        <polygon class='triangle play' fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" points="16,13 40,25 16,37"/> 
        <circle class='circle' fill="none"  stroke-width="4" stroke-linecap="round" stroke-linejoin="round" cx="25px" cy="25px" r="23px"/>
    </svg>   
</div> -->

END OLF PLAY BUTTON HTML


CODE USED TO REMOVE WEIGHTS FROM HTML ENTIRELY IF UNWEIGHTED, AND ADD THEM BACK IN IF WEIGHTED:

function addAllWeights(){
    // Show all weights.
    for(let i in lines){
        for(let j in lines[i]){
            svg.appendChild(lines[i][j].label);
        }
    }
    for(let node of svg.getElementsByTagNameNS(svgns, "circle")){
        updateAllLines(node);
    }
}

function removeAllWeights(){
    // Unshow all weights.
    for(let i in lines){
        for(let j in lines[i]){
            if(svg.contains(lines[i][j].label)){
                svg.removeChild(lines[i][j].label);
            }
        }
    }
}


// FIRST DFS ATTEMPT:
let fulfilled = [];
async function DFS(node){
    let waitingFor = [];
    discovered.push(node.id);
    node.classList.add("currentNode");
    node.classList.add("discoveredNode");
    await sleep(delay);
    for (let neighbor of adjacencyList[node.id]){
        node.classList.remove("currentNode");
        await sleep(delay);
        let edge = lines[node.id][adjacencyList[node.id].indexOf(neighbor)].lineObject;
        setAttributes(edge, {"stroke" : "green"});
        await sleep(delay);
        if(!discovered.includes(neighbor)){
            DFS(document.getElementById(neighbor));
            waitingFor.push(parseInt(neighbor))
        }
        setAttributes(edge, {"stroke" : "red"}); 
        await sleep(delay);
        if(neighbor != adjacencyList[node.id][adjacencyList[node.id].length-1]){
            node.classList.add("currentNode");
        }
        await sleep(delay);
    }
    // Wait for other DFS calls to finish before marking as finished.
    // Have array of all nodes I need to wait on. Then Promise.all() wait for them to finish. Upon finsihing a node, resolve my node.id promise.
    console.log(node.id + " is waiting for ", waitingFor)
    for(let i = 0; i < waitingFor.length; i++){
        Promise.retry(() => new Promise((resolve, reject) => {
            if(fulfilled[waitingFor[i]]){
                resolve();
            }else{
                reject();
            }
        }, delay))
    }
    node.classList.remove("currentNode");
    node.classList.add("finishedNode");
    fulfilled[node.id] = true;
}




// Initial, step-based DFS. Does not work:

let steps = []; // elements: [], actions: [], classList: [].
let priorEdge = null;
// Create an array of steps. Then loop through each step.
async function DFS(node){
    // Initially, all nodes & edges undiscovered.
    // Highlight node as current:
    if(priorEdge != null){
        steps.push({"elements": [node, node, priorEdge, priorEdge], "actions": ["add", "add", "remove", "add"], "classList": ["discoveredNode", "currentNode", "currentEdge", "finishedEdge"]});
    }else{
        steps.push({"elements": [node, node], "actions": ["add", "add"], "classList": ["discoveredNode", "currentNode"]});
    }
    priorEdge = null;

    // Loop through the edges:
    for(let i in adjacencyList[node.id]){
        // Dehighlight node, moving on to edge:
        // Highlight current edge:
        
        let edge = lines[node.id][i].lineObject;
        steps.push({"elements": [node, edge], "actions": ["remove", "add"], "classList": ["currentNode", "currentEdge"]});

        // Go on to neighbor node:
        let neighbor = document.getElementById(adjacencyList[node.id][i]);
        if(!neighbor.classList.contains("discoveredNode")){
            priorEdge = edge;
            await DFS(neighbor);
            // Neighbor done:
            steps.push({"elements": [neighbor, neighbor, node], "actions": ["remove", "add", "add"], "classList": ["currentNode", "finishedNode", "currentNode"]});
        }else{
            steps.push({"elements": [edge, edge, node], "actions": ["remove", "add", "add"], "classList": ["currentEdge", "finishedEdge", "currentNode"]});
        }
   }

   // Node finished:
   if(node == startNode){
        steps.push({"elements": [node, node], "actions": ["remove", "add"], "classList": ["currentNode", "finishedNode"]});
    }
   return Promise.resolve();
}






let priorEdge = null;

// Step-based, no codetrace. 27 steps for 8-node, 9 edge test case:
async function DFS3(node){
    // Initially, all nodes & edges undiscovered.
    // Highlight node as current:
    if(priorEdge == null){
        steps.push({"elements": [node, node], "actions": ["add", "add"], "classList": ["discoveredNode", "currentNode"]});
    }else{
        steps.push({"elements": [node, node, priorEdge], "actions": ["add", "add", "remove"], "classList": ["discoveredNode", "currentNode", "currentEdge"]});
    }
    priorEdge = null;
    discovered.push(node.id);

    // Loop through the edges:
    for(let i in adjacencyList[node.id]){
        let edge = lines[node.id][i].lineObject;

        // Dehighlight node, highlight current edge.
        steps.push({"elements": [node, edge, edge], "actions": ["remove", "add", "add"], "classList": ["currentNode", "discoveredEdge", "currentEdge"]});

        // Go on to neighbor node:
        let neighbor = document.getElementById(adjacencyList[node.id][i]);
        if(!discovered.includes(neighbor.id)){
            priorEdge = edge;
            await DFS3(neighbor);
            steps[steps.length-1] = {"elements": [neighbor, neighbor, node], "actions": ["remove", "add", "add"], "classList": ["currentNode", "finishedNode", "currentNode"]}; // Override prior entry to make node current.
        }else{
            // Node already discovered, so this edge will not actually be explored.
            steps.push({"elements": [edge, node], "actions": ["remove", "add"], "classList": ["currentEdge", "currentNode"]});
        }
    }
   
    // Node finished:
    steps.push({"elements": [node, node], "actions": ["remove", "add"], "classList": ["currentNode", "finishedNode"]});  // If node is startNode, this will not be overridden. Mark node as finished.
    return Promise.resolve();
}

// Not step-based. Also 27 steps for 8 node, 9 edge test case, but no scrubbing possible without step array.:
async function DFS2(node){
    // Initially, all nodes & edges undiscovered.
    // Highlight node as current:
    node.classList.add("discoveredNode");
    node.classList.add("currentNode");
    await sleep(baseWait/speed);

    if(btn.classList.contains("play")){
        await waitListener(btn,"click");
    }

    // Loop through the edges:
    for(let i in adjacencyList[node.id]){
        // Dehighlight node, moving on to edge:
        node.classList.remove("currentNode");

        // Highlight current edge:
        let edge = lines[node.id][i].lineObject;
        setAttributes(edge, {"stroke": "green"});
        await sleep(baseWait/speed);

        if(btn.classList.contains("play")){
            await waitListener(btn,"click");
        }

        // Go on to neighbor node:
        let neighbor = document.getElementById(adjacencyList[node.id][i]);
        setAttributes(edge, {"stroke": "red"});
        if(!neighbor.classList.contains("discoveredNode")){
            await DFS2(neighbor);
        }
        node.classList.add("currentNode");
        await sleep(baseWait/speed);
        if(btn.classList.contains("play")){
            await waitListener(btn,"click");
        }
   }

   // Node finished:
   node.classList.remove("currentNode");
   node.classList.add("finishedNode");
   return Promise.resolve();
}




OLD WEIGHT VISIBILITY CODE:

function makeWeightsVisible(){
    for(let i in lines){
        for(let j in lines[i]){
            setAttributes(lines[i][j].label, {"pointer-events": "auto", "opacity": 1});
        }
    }
}

function makeWeightsInvisible(){
    for(let i in lines){
        for(let j in lines[i]){
            setAttributes(lines[i][j].label, {"pointer-events": "none", "opacity": 0});
        }
    }
    if(newWeightText != null){
        setAttributes(newWeightText, {"pointer-events": "none", "opacity": 0});
    }
}



OLD SETWEIGHTED:
function setWeighted(newWeight){
    if(weighted != newWeight){
        weighted = newWeight;
        if(weighted){
            // addAllWeights();
            changeWeightVisibility(true);
            // makeWeightsVisible();
        }else{
            // removeAllWeights();
            changeWeightVisibility(false);
            // makeWeightsInvisible();
        }
        console.log((weighted ? "" : "un") + "weighted");
    }
}





OLD COMMENTS:
/****************************************
// We can display where we are in code with method 1. However, it is hard to scrub through (especially backwards. we can probably run DFS first to get numSteps, then have a count variable incremented each step to scrub forwards, but backwards is impossible).
// We can  allow for scrubbing through specific steps with method 2. With extra data, we can display where we are.
****************************************/